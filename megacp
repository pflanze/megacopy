#!/usr/bin/perl -w

# Copyright 2014 by Christian Jaeger. Published as Open Source
# software under the MIT License. See COPYING.md

(my $email='ch%christianjaeger,ch')=~ tr/%,/@./;

use strict; use warnings FATAL => 'uninitialized';

use Cwd 'abs_path';

our ($mydir, $myname);
BEGIN {
    my $location= (-l $0) ? abs_path ($0) : $0;
    $location=~ /(.*?)([^\/]+?)_?\z/s or die "?";
    ($mydir, $myname)=($1,$2);
}

our $MAX_SMALL_FILE= 8*1024*1024;
our $MKDIR_MASK= 0700;

sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname [--] sourcedir targetdir

  Like cp -a sourcedir targetdir, except:

   - targetdir must not yet exist
   - only does sparse copying for files over $MAX_SMALL_FILE bytes

  and should hopefully be less RAM hungry with huge number of files.

  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

use Getopt::Long;
our $verbose=0;
#our $opt_dry;
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   #"dry-run"=> \$opt_dry,
	   ) or exit 1;
usage unless @ARGV==2;

our ($source,$target)=@ARGV;

use lib "$mydir/lib";

use PFLANZE::Fileutils ":all";
$PFLANZE::Fileutils::verbose= $verbose;

use PFLANZE::copy "copy_fast";

use PFLANZE::Xstat ":all";

our @STORE_STATFIELDS= qw(dev ino mode uid gid size atime mtime);
sub stat_from_fields {
    @_ == @STORE_STATFIELDS or die "received wrong number of fields";
    my $s= bless [], "Chj::xperlfunc::xstat";
    for (my $i=0; $i< @STORE_STATFIELDS; $i++) {
	my $m= "set_".$STORE_STATFIELDS[$i];
	$s->$m($_[$i]);
    }
    $s
}



our $files= xtempfile;
our $dirs= xtempfile;

sub scanprint {
    my ($subpath)=@_;
    my $path= "$source$subpath";
    opendir my $dir, $path
      or die "opendir '$path': $!";
    while (defined (my $item= readdir $dir)) {
	next if ($item eq "." or $item eq "..");
	my $subpath= "$subpath/$item";
	my $path= "$source$subpath";
	my $s= xlstat $path;
	my $fields= join("/", map{ $s->$_ } @STORE_STATFIELDS);
	if ($s->is_dir) {
	    $dirs->xprint("$fields $subpath\0");
	    scanprint ($subpath);
	} else {
	    $files->xprint("$fields $subpath\0");
	}
    }
    closedir $dir
      or die "closing '$path': $!";
}

scanprint "";
$_->xclose for ($files, $dirs);

our $sortedfiles= xsortfile $files->path;
$files->xunlink;


# create target directories
#-d $target or
mkdir $target, $MKDIR_MASK
  or die "mkdir '$target': $!";
{
    my $in= $dirs->reader;
    my $fh= $in->fh;
    local $/="\0";
    while (<$fh>) {
	chomp;
	my ($fields,$subpath)= split " " or die;
	my $s= stat_from_fields(split "/", $fields);

	my $path= "$target$subpath";
	mkdir $path, $MKDIR_MASK
	  or die "mkdir '$path': $!";
    }
    $in->xclose;
}

# copy files
{
    my $in= PFLANZE::File->xopen("<",$sortedfiles);
    my $fh= $in->fh;
    local $/="\0";
    my $cur_s;
    my @paths;
    my $act= sub {
	my ($next_s)=@_;
	{
	    my $firstpath= shift @paths;
	    my $s= $cur_s;
	    my $size= $s->size;
	    if (not($s->is_file) or $size > $MAX_SMALL_FILE) {
		# use cp command, if only to get support for holes?
		xxsystem "cp", "-a", "--", $source.$firstpath, $target.$firstpath;
	    } else {
		my $tpath= $target.$firstpath;
		copy_fast($source.$firstpath, $tpath, $size)
		  or die "copy('$source.$firstpath', '$tpath'): $!";
		utime $s->atime, $s->mtime, $tpath
		  or die "utime '$tpath': $!";
		chown $s->uid, $s->gid, $tpath
		  or die "chown '$tpath': $!";
		chmod $s->permissions, $tpath
		  or die "chmod '$tpath': $!";
	    }
	    for (@paths) {
		xlink $target.$firstpath, $target.$_;
		# (Handle case where some of the target locations are
		# on different filesystems? But can't happen if we
		# enforce mkdir first.)
	    }
	}
	$cur_s= $next_s;
	@paths=();
    };
    while (<$fh>) {
	chomp;
	my ($fields,$path)= split " " or die;
	my $s= stat_from_fields(split "/", $fields);
	#warn "path='$path'";
	if (defined $cur_s) {
	    if (not $s->same_node($cur_s)) {
		&$act ($s);
	    }
	} else {
	    $cur_s= $s;
	}
	push @paths, $path;
    }
    &$act(undef) if defined $cur_s;
    $in->xclose;
    $in->xunlink;
}


# copy dir permissions + time stamps

## XX ; explicitely include toplevel dir! ehr or rather, change algo
## to stat first when scanning

{
    # (partially copy paste again, well)
    my $in= $dirs->reader;
    my $fh= $in->fh;
    local $/="\0";
    while (<$fh>) {
	chomp;
	my ($fields,$subpath)= split " " or die;
	my $s= stat_from_fields(split "/", $fields);

	my $tpath= "$target$subpath";
	# (and this is copy paste from the file loop)
	utime $s->atime, $s->mtime, $tpath
	  or die "utime '$tpath': $!";
	chown $s->uid, $s->gid, $tpath
	  or die "chown '$tpath': $!";
	chmod $s->permissions, $tpath
	  or die "chmod '$tpath': $!";
    }
    $in->xclose;
}


$dirs->xunlink;


#use Chj::ruse;
#use Chj::Backtrace; use Chj::repl; repl;
